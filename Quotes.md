> Ripple counters do not follow these principles and should generally be avoided if at all possible. We will now look at the problems with ripple counters.
> *- Ian Wassel, Digital Electronics, Computer Science Tripos Part IA*

> A baby's name can be chosen by intersecting the preferences of both parents...
> `int(["John", "James", "Mark"], ["Nebuchadnezzar", "Bede"]);`
> ... although this seldom works.
>*- 3.15 Polymorphic set operations, ML for the Working Programmer, L.C. Paulson*

> The imperative program shown above is hardly cleaner or shorter than the functional example. Proving that it correctly implements Euclid's algorithm requires Floyd-Hoare proofs - a tedious enterprise. In contrast, the functional version obviously implements Euclid's algorithm.
> *- OCaml from the very beginning, John Whitington*

> Beware of redeclaring a datatype. Each `datatype` declaration creates a new type distinct from all others. Suppose we have declared the type `degree` and the function `lady`. Now, repeat the declaration of `degree`. Asking for the type of `lady(Duke)` will elicit the type error: "expected type `degree`, found `degree`."
> Two different types are now called `degree`. This exasperating situation can happen while a program is being modified interactively. The surest remedy is to **terminate the ML session, start a new one, and load the program afresh**. (????????)
> *- 4.2 Enumeration types, ML for the Working Programmer, L.C. Paulson

> Despite the arboreal terminology, trees are usually drawn upside down.
> *- 4.10 A type for binary trees, ML for the Working Programmer, L.C. Paulson*


